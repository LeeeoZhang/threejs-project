<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Plane!!</title>
	<script src="./js/three.min.js"></script>
	<style>
		*{margin: 0;padding: 0;}
		html,body {
			width: 100%;
			height: 100%;
			position: relative;
			overflow: hidden;
		}
		#world {
			width: 100%;
			height: 100%;
			position: absolute;
			left: 0;
			top: 0;
			overflow: hidden;
			background: linear-gradient(#e4e0ba, #f7d9aa);
		}
	</style>
</head>
<body>
	<div id="world"></div>
	<script>
		//调色板
		const Colors = {
			red: 0xf25346,
			white:0xd8d0d1,  
   			brown:0x59332e,  
   			pink:0xF5986E,   
   			brownDark:0x23190f,  
   			blue:0x68c3c0
		}

		window.addEventListener('load',init,false)

		function init(){
			//创建场景，相机和渲染器
			createScene()
			//添加光源
			createLights()
			//添加对象
			createPlane()
			createSea()
			createSky()
			//循环调用函数,在每帧更新对象的位置和渲染场景
			loop()

			//监听鼠标事件
			document.addEventListener('mousemove',handleMouseMove,false)
		}

		//场景的相关参数
		let scene,camera,fieldOfView,aspectRatio,nearPlane,farPlane,HEIGHT,WIDTH,renderer,container	
		function handleWindowResize(){
			HEIGHT = window.innerHeight
			WIDTH = window.innerWidth
			renderer.setSize(WIDTH,HEIGHT)
			camera.aspect = WIDTH / HEIGHT
			camera.updateProjectionMatrix()
		}

		function createScene(){
			//获取屏幕宽高,设置相机纵横比和渲染器大小
			HEIGHT = window.innerHeight
			WIDTH = window.innerWidth

			//创建一个场景
			scene = new THREE.Scene()

			//在场景中添加雾的效果,试用和背景一样的颜色
			scene.fog = new THREE.Fog(0xf7d9aa, 100, 950)

			//创建一个透视相机
			aspectRatio = WIDTH / HEIGHT 	//纵横比
			fieldOfView = 60				//视角
			nearPlane = 1					//近平面
			farPlane = 10000				//远平面
			camera = new THREE.PerspectiveCamera(fieldOfView,aspectRatio,nearPlane,farPlane)

			//设置相机位置
			camera.position.x = 0
			camera.position.y = 200
			camera.position.z = 100

			//创建渲染器
			renderer = new THREE.WebGLRenderer({
				//背景色透明,显示css中的颜色
				alpha: true,
				//是否开启抗锯齿,对性能有一定影响
				antialias: true	
			})

			//设置渲染器的尺寸,这里是填满整个屏幕
			renderer.setSize(WIDTH,HEIGHT)

			//打开渲染器的阴影地图
			renderer.shadowMap.enabled = true

			//把渲染器dom插入到页面的指定容器中
			container = document.querySelector('#world')
			container.appendChild(renderer.domElement)

			//监听屏幕的resize,更新相机的纵横比
			window.addEventListener('resize',handleWindowResize,false)
		}

		//光源相关参数
		let hemisphereLight, shadowLight
		function createLights(){
			//选用半球光,半球光就是渐变的光
			//参数 天空颜色,地面颜色,光的强度
			hemisphereLight = new THREE.HemisphereLight(0xaaaaaa,0x000000, 0.9)

			//还用到了方向光
			//方向光是类似太阳,从特定一个方向照射的平行光
			//参数 关系颜色,光的强度
			shadowLight = new THREE.DirectionalLight(0xffffff, .9)

			//设置方向光的方向
			//不同方向作用在物体的面也不同,表现出的颜色也不同
			shadowLight.position.set(150,350,350)

			//开启光源投影
			shadowLight.castShadow = true

			// 定义可见域的投射阴影
   			shadowLight.shadow.camera.left = -400;
   			shadowLight.shadow.camera.right = 400;
   			shadowLight.shadow.camera.top = 400;
   			shadowLight.shadow.camera.bottom = -400;
   			shadowLight.shadow.camera.near = 1;
   			shadowLight.shadow.camera.far = 1000;

   			//定义阴影分辨率,质量越好,需求性能越高
	   		shadowLight.shadow.mapSize.width = 2048;
		   	shadowLight.shadow.mapSize.height = 2048;

		   	//把光源添加到场景中才能生效
		   	scene.add(hemisphereLight)
		   	scene.add(shadowLight)
		}

		//定义大海对象
		function Sea(){
			//创建一个圆柱几何体
			//参数 顶面半径,地面半径,高度,半径分段,高度分段
			let geom = new THREE.CylinderGeometry(600,600,800,40,10)

			//在x轴旋转几何体
			geom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2))

			//创建材质
			let mat = new THREE.MeshPhongMaterial({
				color:Colors.blue,
       			transparent:true,
       			opacity:.6,
       			shading:THREE.FlatShading,
			})

			//使用网格用来组合几何和一些材质
			this.mesh = new THREE.Mesh(geom,mat)

			//允许大海对象接收阴影
			this.mesh.receiveShadow = true
		}

		//创建对象，
		//我们需要：
		//创建几何体
		//创建材质
		//将它们传入网格
		//将网格添加至场景
		//实例化大海
		let sea
		function createSea(){
			sea = new Sea()
			sea.mesh.position.y = -500
			//添加大海到场景
			scene.add(sea.mesh)
		}

		//定义一个云对象
		function Cloud(){
			//创建一个容器来放置不同的云
			this.mesh = new THREE.Object3D()

			//创建一个正方体
			//这个正方体会被重复复制用来创建云
			let geom = new THREE.BoxGeometry(20,20,20)

			//创建材质
			let mat = new THREE.MeshPhongMaterial({
       			color: Colors.white,  
   			});

			//随机多次复制几何体
			let nBlocs = 3 + Math.floor(Math.random()*3)
			for(let i =1;i<nBlocs;i++) {

				let m = new THREE.Mesh(geom,mat)

				//随机设置正方体的位置和旋转角度
				m.position.x = i*15
       			m.position.y = Math.random()*10
       			m.position.z = Math.random()*10
       			m.rotation.z = Math.random()*Math.PI*2
       			m.rotation.y = Math.random()*Math.PI*2

       			//随机设置正方体大小
       			let s = 0.1 + Math.random()*0.9
       			m.scale.set(s,s,s)

       			//允许每个正方体生成投影和接收阴影
       			m.castShadow = true
       			m.receiveShadow = true

       			//将正方体添加到开始的容器中
       			this.mesh.add(m)
			}
		}

		//定义天空对象
		function Sky (){
			//创建空容器
			this.mesh = new THREE.Object3D()

			//选取若干朵云散步在空中
			this.nClouds = 20

			//根据一定的角度放置云,散布在空中
			let setpAngle = Math.PI*2 / this.nClouds

			//创建云对象
			for(let i =0;i<this.nClouds;i++) {
				let c = new Cloud()

				//设置每朵云的旋转角度和位置
				let a = setpAngle*i
				let h = 750 + Math.random()*200		//轴的中心和云本身之间的距离

				c.mesh.position.y = Math.sin(a)*h
				c.mesh.position.x = Math.cos(a)*h

				//根据云的位置旋转
				c.mesh.rotation.z = a + Math.PI/2

				//我们把云放置在场景中的随机深度位置
       			c.mesh.position.z = -400-Math.random()*400;
    
			    //每朵云设置一个随机大小
			    let s = 1+Math.random()*2;
			    c.mesh.scale.set(s,s,s);

			    //把云的网格添加到场景中
			    this.mesh.add(c.mesh)
			}
		}

		//实例化天空
		let sky
		function createSky(){
			sky = new Sky()
			sky.mesh.position.y = -600
			scene.add(sky.mesh)
		}

		//定义飞机
		function AirPlane(){
			this.mesh = new THREE.Object3D()

			//创建机舱
			let geomCockpit = new THREE.BoxGeometry(60, 50, 50, 1, 1, 1)
			let matCockpit = new THREE.MeshPhongMaterial({
				color: Colors.red,
				shading: THREE.FlatShading
			})
			let cockpit = new THREE.Mesh(geomCockpit,matCockpit)
			cockpit.castShadow = true;
		    cockpit.receiveShadow = true;
		    this.mesh.add(cockpit); 

		    //创建引擎
		    let geomEngine = new THREE.BoxGeometry(20, 50, 50, 1, 1, 1)
		    let matEngine = new THREE.MeshPhongMaterial({
         		color: Colors.white,
         		shading: THREE.FlatShading
   			})
   			let engine = new THREE.Mesh(geomEngine,matEngine)
   			engine.position.x = 40
   			engine.castShadow = true
		    engine.receiveShadow = true
		    this.mesh.add(engine)

		    // 创建机尾
		    let geomTailPlane = new THREE.BoxGeometry(15, 20, 5, 1, 1, 1)
		    let matTailPlane = new THREE.MeshPhongMaterial({
		        color: Colors.red,
		        shading: THREE.FlatShading
		    })
		    let tailPlane = new THREE.Mesh(geomTailPlane, matTailPlane)
		    tailPlane.position.set(-35, 25, 0)
		    tailPlane.castShadow = true
		    tailPlane.receiveShadow = true
		    this.mesh.add(tailPlane)

		    //创建机翼
		    let geomSideWing = new THREE.BoxGeometry(40,8,150,1,1,1)
		    let matSideWing = new THREE.MeshPhongMaterial({
		    	color: Colors.red,
		    	shading: THREE.FlatShading
		    })
		    let sideWing = new THREE.Mesh(geomSideWing,matSideWing)
		    sideWing.castShadow = true
   			sideWing.receiveShadow = true
   			this.mesh.add(sideWing)

   			// 创建螺旋桨
   			let geomPropeller = new THREE.BoxGeometry(20, 10, 10, 1, 1, 1);
   			let matPropeller = new THREE.MeshPhongMaterial({
       			color: Colors.brown,
       			shading: THREE.FlatShading
   			});
   			this.propeller = new THREE.Mesh(geomPropeller, matPropeller);
   			this.propeller.castShadow = true;
   			this.propeller.receiveShadow = true;

   			//创建螺旋桨的桨叶
   			let geomBlade = new THREE.BoxGeometry(1,100,20,1,1,1)
   			let matBlade = new THREE.MeshPhongMaterial({
   				color: Colors.brownDark,
       			shading: THREE.FlatShading
   			})
   			let blade = new THREE.Mesh(geomBlade,matBlade)
   			blade.position.set(8,0,0)
   			blade.castShadow = true
   			blade.receiveShadow = true
   			this.propeller.add(blade)
   			this.propeller.position.set(50,0,0)
   			this.mesh.add(this.propeller)
		}

		//实例化飞机
		let airplane
		function createPlane(){
			airplane = new AirPlane()
			airplane.mesh.scale.set(0.25,0.25,0.25)
			airplane.mesh.position.y = 100
			scene.add(airplane.mesh)
		}

		//场景运动
		function loop(){
			//使螺旋桨旋转并转动大海和云
			sea.mesh.rotation.z += 0.005
			sky.mesh.rotation.z += 0.01

			//每帧更新飞机位置
			updatePlane()

			//渲染场景
			renderer.render(scene,camera)
			requestAnimationFrame(loop)
		}

		let mousePos = {x:0,y:0}
		function handleMouseMove(event){
			//把鼠标位置的值进行归一化,在-1,1之间变化
			let tx = -1 + (event.clientX / WIDTH)*2

			//2d的y轴与3d的y轴是反的,换算
			let ty = 1 - (event.clientY / HEIGHT)*2
			mousePos = {x:tx,y:ty}
		}
		function updatePlane(){
			// 让我们在x轴上-100至100之间和y轴25至175之间移动飞机
   			// 根据鼠标的位置在-1与1之间的范围，我们使用的normalize函数
   			let targetX = normalize(mousePos.x, -1, 1, -100, 100)
   			let targetY = normalize(mousePos.y, -1, 1, 125, 275)
		    // 更新飞机的位置
		    airplane.mesh.position.y = targetY
		    airplane.mesh.position.x = targetX
		    airplane.propeller.rotation.x += 0.3
		}

		function normalize(v,vmin,vmax,tmin, tmax){

		   let nv = Math.max(Math.min(v,vmax), vmin)
		   let dv = vmax-vmin
		   let pc = (nv-vmin)/dv
		   let dt = tmax-tmin
		   let tv = tmin + (pc*dt)
		   return tv
		}

	</script>
</body>
</html>